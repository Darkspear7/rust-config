use types::{SettingsList, Setting, Value, ScalarValue, ArrayValue, ListValue};
use syntax::parse;

#[pub]
conf -> SettingsList
    = __ l:settings_list { l }

settings_list -> SettingsList
    = l:setting*
      {
          let mut res = SettingsList::new();
          for setting in l.into_iter() {
              res.insert(setting.name.clone(), setting);
          }
          res
      }

setting -> Setting
    = __ n:name __ (":" / "=") __ v:value __ ";" __ { Setting::new(n, v) }

value -> Value
    = sv:scalar_value { Value::Svalue(sv) }
    / av:array_value { Value::Array(av) }
    / lv:list_value { Value::List(lv) }
    / gv:group_value { Value::Group(gv) }

/* Make sure to update `array_elements` if this changes */
scalar_value -> ScalarValue
    = v:boolean_scalar_value { v }
    / v:floating64_scalar_value { v }
    / v:floating32_scalar_value { v }
    / v:integer64_scalar_value { v }
    / v:integer32_scalar_value { v }
    / v:str_scalar_value { v }

/* This rule enforces the requirement that arrays are homogeneous and
 * only hold scalar values.
 * Make sure to update `scalar_value` if this changes
 */
array_elements -> Vec<ScalarValue>
    = "[" __ l:boolean_scalar_value ** (__ "," __) __ "]" { l }
    / "[" __ l:floating64_scalar_value ** (__ "," __) __ "]" { l }
    / "[" __ l:floating32_scalar_value ** (__ "," __) __ "]" { l }
    / "[" __ l:integer64_scalar_value ** (__ "," __) __ "]" { l }
    / "[" __ l:integer32_scalar_value ** (__ "," __) __ "]" { l }
    / "[" __ l:str_scalar_value ** (__ "," __) __ "]" { l }

array_value -> ArrayValue
    = l:array_elements
      {
         let mut res = ArrayValue::new();
         for scalar_val in l.into_iter() {
             res.push(Value::Svalue(scalar_val));
         }
         res
      }

list_value -> ListValue
    = "(" __ l:value ** (__ "," __) __ ")" { l }

group_value -> SettingsList
    = "{" sl:settings_list "}" { sl }

name -> String
    = [a-zA-Z][-a-zA-Z0-9_]* { match_str.to_string() }

boolean_scalar_value -> ScalarValue
    = [Tt][Rr][Uu][Ee] { ScalarValue::Boolean(true) }
    / [Yy][Ee][Ss] { ScalarValue::Boolean(true) }
    / [Ff][Aa][Ll][Ss][Ee] { ScalarValue::Boolean(false) }
    / [Nn][Oo] { ScalarValue::Boolean(false) }

integer32_scalar_value -> ScalarValue
    = [+-]?[0-9]+ { ScalarValue::Integer32(match_str.parse::<i32>().unwrap()) }

integer64_scalar_value -> ScalarValue
    = [+-]?[0-9]+"L" { ScalarValue::Integer64((&match_str[..match_str.len()-1]).parse::<i64>().unwrap()) }

floating32_scalar_value -> ScalarValue
     = [+-]?([0-9]*)?"."[0-9]*([eE][+-]?[0-9]+)? { ScalarValue::Floating32(match_str.parse::<f32>().unwrap()) }
     / [+-]([0-9]+)("."[0-9]*)?[eE][+-]?[0-9]+ { ScalarValue::Floating32(match_str.parse::<f32>().unwrap()) }

floating64_scalar_value -> ScalarValue
    = ([+-]?([0-9]*)?"."[0-9]*([eE][+-]?[0-9]+)?)"L" { ScalarValue::Floating64((&match_str[..match_str.len()-1]).parse::<f64>().unwrap()) }
    / ([+-]([0-9]+)("."[0-9]*)?[eE][+-]?[0-9]+)"L" { ScalarValue::Floating64((&match_str[..match_str.len()-1]).parse::<f64>().unwrap()) }

str_scalar_value -> ScalarValue
    = "\"" ([^\"\\]/"\\".)* "\"" { ScalarValue::Str(parse::str_lit(&match_str[1..match_str.len()-1])) }


/* The following rules were copied
 * from rust-peg source, see https://github.com/kevinmehall/rust-peg/blob/master/src/grammar.rustpeg
 */

__ = (whitespace / eol / comment)*

/* Modeled after ECMA-262, 5th ed., 7.4. */
comment
  = singleLineComment
  / multiLineComment

singleLineComment
  = ("//"/"#") (!eolChar .)*

multiLineComment
  = "/*" (!"*/" .)* "*/"

/* Modeled after ECMA-262, 5th ed., 7.3. */
eol
  = "\n"
  / "\r\n"
  / "\r"
  / "\u{2028}"
  / "\u{2029}"

eolChar
  = [\n\r\u2028\u2029]

/* Modeled after ECMA-262, 5th ed., 7.2. */
whitespace
  = [ \t\u{00A0}\u{FEFF}\u{1680}\u{180E}\u{2000}-\u{200A}\u{202F}\u{205F}\u{3000}] // \v\f removed
